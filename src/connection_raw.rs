// We allow non_snake_case because it more convient to have the impls of RawConnection directly map to libpq functions.
#![allow(non_snake_case)]

use crate::libpq;

use crate::query_raw::RawQueryResult;

/// Sendable query result type.
/// Used to ensure that the underlying *mut libpq::PGresult is not utilized in multiple threads.
pub(crate) struct SendableQueryResult {
    /// Private! We only want SendableQueryResult being constructed by wrapper functions that would return *mut PGresult
    result: Option<*mut libpq::PGresult>,
}

// SAFETY: We send the SendableQueryResult to the receiving end which unwraps into a RawQueryResult.
// The underlying pointer is never used until during or after the SendableQueryResult is unwrapped.
// Unwrap consumes the SendableQueryResult, so it can only be run once.
// The unwrapped type RawQueryResult is !Send, due to having a *mut and not being marked as unsafe impl Send.
unsafe impl Send for SendableQueryResult {}

impl SendableQueryResult {
    pub(crate) fn unwrap(mut self) -> RawQueryResult {
        // Can't actually panic, as it's only constructed with Some() and its only made None via consuming.
        RawQueryResult {
            result: self.result.take().unwrap(),
        }
    }
}

impl Drop for SendableQueryResult {
    fn drop(&mut self) {
        match self.result {
            None => (),
            // The SendableQueryResult was dropped before it was unwrapped.
            // This is likely to occur if you don't read the full results of a query.
            // This is because all the results will be sent, whether or not they are received.
            // This is simply how postgres works, it needs to finish reading one query before it goes on to the next query.
            Some(s) => unsafe { libpq::PQclear(s) },
        }
    }
}

/// The private struct containing the raw C pointer to the postgres connection.
/// The underlying unsafe libpq functions that take a *mut PGconn are accessed through impls on RawConnection.
/// We only want the underlying connection pointer to be used in a single thread.
/// From the docs: "As of version 17, libpq is always reentrant and thread-safe.
/// However, one restriction is that no two threads attempt to manipulate the same PGconn object at the same time.
/// In particular, you cannot issue concurrent commands from different threads through the same connection object.
/// (If you need to run concurrent commands, use multiple connections.)"
/// This will be enforced by rust as *mut is already !Send and !Sync, and also we are not impl copy nor clone.
pub(crate) struct RawConnection {
    conn: *mut libpq::PGconn,
}

impl Drop for RawConnection {
    fn drop(&mut self) {
        unsafe { libpq::PQfinish(self.conn) }
    }
}

impl RawConnection {
    /// Makes a new connection to the database server.
    /// Blocks until the connection succeeds or fails. This can take minutes.
    /// Will panic if conninfo contains internal null bytes.
    /// Will panic if attempting to connect returns a null pointer.
    /// According to the docs this implies OOM:
    /// "Note that these functions will always return a non-null object pointer,
    /// unless perhaps there is too little memory even to allocate the PGconn object."
    pub(crate) fn PQconnectdb(conninfo: &str) -> Self {
        let conninfo = std::ffi::CString::new(conninfo)
            .expect("postgres connection strings should not contain internal nulls");
        let conn: *mut libpq::pg_conn = unsafe { libpq::PQconnectdb(conninfo.into_raw()) };
        assert!(
            !conn.is_null(),
            "null pointer returned by libpq when attempting to connect to postgres"
        );
        RawConnection { conn }
    }

    pub(crate) fn PQstatus(&self) -> libpq::ConnStatusType {
        unsafe { libpq::PQstatus(self.conn) }
    }

    pub(crate) fn PQexec(&self, command: &str) -> SendableQueryResult {
        let command = std::ffi::CString::new(command)
            .expect("postgres queries should not contain internal nulls");
        unsafe {
            SendableQueryResult {
                result: Some(libpq::PQexec(self.conn, command.into_raw())),
            }
        }
    }

    /// From the docs: "Returns the error message most recently generated by an operation on the connection."
    /// Will panic if the error message contains invalid utf8.
    pub(crate) fn PQerrorMessage(&self) -> String {
        // SAFETY: The memory of the error message is valid for the lifetime of the connection, and we copy it immediately.
        let raw_error_message: &std::ffi::CStr =
            unsafe { std::ffi::CStr::from_ptr(libpq::PQerrorMessage(self.conn)) };
        let mut result: String = String::from(raw_error_message.to_str().unwrap());
        // Postgres error messages have a trailing newline, which I don't like.
        result.pop();
        result
    }
}
