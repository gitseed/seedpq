// We allow non_snake_case because it more convenient to have the impls of RawConnection directly map to libpq functions.
#![allow(non_snake_case)]

use crate::libpq;

use crate::query_raw::RawQueryResult;

use std::ptr::null;

/// The private struct containing the raw C pointer to the postgres connection.
/// The underlying unsafe libpq functions that take a *mut PGconn are accessed through impls on RawConnection.
/// We only want the underlying connection pointer to be used in a single thread.
/// From the docs: "As of version 17, libpq is always reentrant and thread-safe.
/// However, one restriction is that no two threads attempt to manipulate the same PGconn object at the same time.
/// In particular, you cannot issue concurrent commands from different threads through the same connection object.
/// (If you need to run concurrent commands, use multiple connections.)"
/// This will be enforced by rust as *mut is already !Send and !Sync, and also we are not impl copy nor clone.
pub(crate) struct RawConnection(*mut libpq::PGconn);

impl Drop for RawConnection {
    fn drop(&mut self) {
        unsafe { libpq::PQfinish(self.0) }
    }
}

// Custom methods of RawConnection.
impl RawConnection {
    /// Send a command to the database to be executed.
    /// Will return true if the command was successfully dispatched, false otherwise.
    pub(crate) fn exec(&self, command: &str) -> bool {
        let command = std::ffi::CString::new(command)
            .expect("postgres queries should not contain internal nulls");
        let result: std::ffi::c_int = unsafe {
            libpq::PQsendQueryParams(
                self.0,
                command.into_raw(),
                0,
                null(),
                null(),
                null(),
                null(),
                // Specify zero to obtain results in text format, or one to obtain results in binary format.
                // If you specify text format then numbers wil be sent in text form which is dumb.
                1,
            )
        };
        result == 1
    }
}

pub type ConnStatusType = libpq::ConnStatusType;

// Methods of RawConnection that are thin wrappers around methods on PQConn.
impl RawConnection {
    /// Makes a new connection to the database server.
    /// Blocks until the connection succeeds or fails. This can take minutes.
    /// Will panic if conninfo contains internal null bytes.
    /// Will panic if attempting to connect returns a null pointer.
    /// According to the docs this implies OOM:
    /// "Note that these functions will always return a non-null object pointer,
    /// unless perhaps there is too little memory even to allocate the PGconn object."
    pub(crate) fn PQconnectdb(conninfo: &str) -> Self {
        let conninfo = std::ffi::CString::new(conninfo)
            .expect("postgres connection strings should not contain internal nulls");
        let conn: *mut libpq::pg_conn = unsafe { libpq::PQconnectdb(conninfo.into_raw()) };
        assert!(
            !conn.is_null(),
            "null pointer returned by libpq when attempting to connect to postgres, suggesting lack of RAM"
        );
        RawConnection(conn)
    }

    pub(crate) fn PQstatus(&self) -> libpq::ConnStatusType {
        unsafe { libpq::PQstatus(self.0) }
    }

    /// From the docs: "Returns the error message most recently generated by an operation on the connection."
    pub(crate) fn PQerrorMessage(&self) -> String {
        // SAFETY: The memory of the error message is valid for the lifetime of the connection, and we copy it immediately.
        let raw_error_message: &std::ffi::CStr =
            unsafe { std::ffi::CStr::from_ptr(libpq::PQerrorMessage(self.0)) };
        let mut result: String = raw_error_message.to_string_lossy().into_owned();
        // Postgres error messages have a trailing newline, which I don't like.
        result.pop();
        result
    }

    pub(crate) fn PQsetNoticeReceiver(
        &self,
        func: unsafe extern "C" fn(arg: *mut ::std::ffi::c_void, res: *const libpq::PGresult),
        arg: *mut std::ffi::c_void,
    ) {
        unsafe { libpq::PQsetNoticeReceiver(self.0, Some(func), arg) };
    }

    /// Return true if chunked rows mode was set correctly, false otherwise.
    pub(crate) fn PQsetChunkedRowsMode(&self, chunk_size: std::ffi::c_int) -> bool {
        (unsafe { libpq::PQsetChunkedRowsMode(self.0, chunk_size) } == 1)
    }

    pub(crate) fn PQgetResult(&self) -> Option<RawQueryResult> {
        let result: *mut libpq::pg_result = unsafe { libpq::PQgetResult(self.0) };
        if result.is_null() {
            None
        } else {
            Some(RawQueryResult::new(result))
        }
    }
}

pub unsafe extern "C" fn custom_notice_receiver(
    userdata: *mut std::ffi::c_void,
    pg_result: *const libpq::PGresult,
) {
    {
        // SAFETY: The memory of the error message is valid for the lifetime of the function call.
        // We copy it immediately to an owned value.
        // It's not documented, but we can see after calling the notice receiver function, that PGresult is cleared.
        // https://github.com/postgres/postgres/blob/REL_17_6/src/interfaces/libpq/fe-exec.c#L980
        // Therefore we should *NOT* call PGclear ourselves here!
        let message: &std::ffi::CStr =
            unsafe { std::ffi::CStr::from_ptr(libpq::PQresultErrorMessage(pg_result)) };
        let message: String = message.to_string_lossy().into_owned();

        // SAFETY: LOL idk prayge.
        // If there's a better way to do this let me know.
        // I don't trust clippy here. Won't clippy's suggestion have the thing be dropped?
        #[allow(clippy::transmute_ptr_to_ref)]
        let s: &std::sync::mpsc::Sender<String> = unsafe { std::mem::transmute(userdata) };
        _ = s.send(message);
    }
}
